---
Rule Type: Auto Attached
globs: '**/*.ts
---
## CODING_PRACTICES

### Guidelines for SUPPORT_LEVEL

#### SUPPORT_EXPERT

- Favor elegant, maintainable solutions with verbose code. Assume understanding of language idioms and design patterns.
- Highlight potential performance implications and optimization opportunities in suggested code.
- Frame solutions within broader architectural contexts and suggest design alternatives when appropriate.
- Focus comments on 'why' not 'what' - assume code readability through well-named functions and variables.
- Proactively address edge cases, race conditions, and security considerations without being prompted.
- When debugging, provide targeted diagnostic approaches rather than shotgun solutions.
- Suggest comprehensive testing strategies rather than just example tests, including considerations for mocking, test organization, and coverage.

### Guidelines for DOCUMENTATION

#### DOC_UPDATES

- Update relevant documentation in /docs when modifying features
- Keep README.md in sync with new capabilities
- Maintain changelog entries in CHANGELOG.md

## CODING_PRACTICES

### Guidelines for CODE_DOCUMENTATION

- Don't use JSDoc or similar, unless specificaly requested

### Guidelines for VERSION_CONTROL

#### GIT

- Use conventional commits to create meaningful commit messages
- Use feature branches with descriptive names following {{branch_naming_convention}}
- Write meaningful commit messages that explain why changes were made, not just what
- Keep commits focused on single logical changes to facilitate code review and bisection
- Use interactive rebase to clean up history before merging feature branches
- Leverage git hooks to enforce code quality checks before commits and pushes

### Guidelines for VERSION_CONTROL

#### GITHUB

- Use pull request templates to standardize information provided for code reviews
- Implement branch protection rules for {{protected_branches}} to enforce quality checks
- Configure required status checks to prevent merging code that fails tests or linting
- Use GitHub Actions for CI/CD workflows to automate testing and deployment
- Implement CODEOWNERS files to automatically assign reviewers based on code paths
- Use GitHub Projects for tracking work items and connecting them to code changes

### Guidelines for NODE

#### TS
- avoid using `any` type

#### NEST

- Use dependency injection for services to improve testability and maintainability following SOLID principles
- Implement custom decorators for cross-cutting concerns to keep code DRY and maintain separation of business logic
- Use interceptors for transforming the response data structure consistently for {{api_standards}}
- Leverage NestJS Guards for authorization to centralize access control logic across all resources
- Implement domain-driven design with modules that encapsulate related functionality and maintain clear boundaries
- Use TypeORM or Mongoose with repository patterns to abstract database operations and simplify testing with mocks

#### MODULE_STRUCTURE

**Clean Architecture with Repository Pattern:**
```
apps/backend/src/{domain}/
├── adapters/              # HTTP layer (controllers)
│   └── {domain}.controller.ts
├── use-cases/             # Business logic layer
│   ├── {operation}.ts
│   └── {operation}.spec.ts
├── infra/                 # Infrastructure layer (database)
│   └── {domain}.repository.ts
├── dto/                   # Request DTOs with validation
│   └── {request}.dto.ts
└── {domain}.module.ts     # NestJS module configuration
```

**Layer Responsibilities:**

**Adapters (HTTP):**
- Controllers only, delegate to use cases, no business logic
- Use case dependencies named with `UseCase` suffix (e.g., `getListsUseCase: GetLists`)
- Method names follow OpenAPI operationId convention

**Use Cases (Business Logic):**
- One class per operation, named without suffix (e.g., `GetLists`, `CreateList`)
- Single `execute()` method
- Depends on repositories, NOT PrismaClient
- Contains business rules and orchestration
- No database queries

**Infrastructure (Database):**
- Repositories encapsulate all Prisma operations
- Named `{Domain}Repository` (e.g., `ListsRepository`)
- Returns Prisma entities
- No business logic

**Module Rules:**
- No `index.ts` file (module exports itself)
- Export only the module, not internal classes
- Cross-domain dependencies TBD

Example:
```typescript
// infra/lists.repository.ts
@Injectable()
export class ListsRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async findManyByUserId(userId: string): Promise<List[]> {
    return this.prisma.list.findMany({ where: { userId } });
  }
}

// use-cases/get-lists.ts
@Injectable()
export class GetLists {
  constructor(private readonly repository: ListsRepository) {}

  async execute(userId: string): Promise<ListDto[]> {
    const lists = await this.repository.findManyByUserId(userId);
    return lists.map(list => this.toDto(list));
  }
}

// adapters/lists.controller.ts
@Controller('v1/lists')
export class ListsController {
  constructor(private readonly getListsUseCase: GetLists) {}

  @Get()
  async getLists(): Promise<GetListsResponseDto> {
    const lists = await this.getListsUseCase.execute('user-id');
    return { lists };
  }
}
```

#### DTO_PATTERN

**Request/Response Type Sharing:**
- Place request interfaces in @gsd/types/api/*.ts (shared with frontend)
- Backend request DTOs implement shared interfaces and add class-validator decorators
- Response DTOs live in @gsd/types (shared interfaces only)
- Backend internal DTOs stay in backend (service layer transformations)

Example:
```typescript
// @gsd/types/api/lists.ts
export interface CreateListRequest {
  name: string;
  isBacklog?: boolean;
}

// apps/backend/src/lists/dto/create-list.dto.ts
export class CreateListDto implements CreateListRequest {
  @IsString() @MinLength(1) @MaxLength(100)
  name: string;

  @IsBoolean() @IsOptional()
  isBacklog?: boolean;
}
```

## DEVOPS

### Guidelines for CI_CD

#### GITHUB_ACTIONS

- Check if `package.json` exists in project root and summarize key scripts
- Check if `.nvmrc` exists in project root
- Check if `.env.example` exists in project root to identify key `env:` variables
- Always use terminal command: `git branch -a | cat` to verify whether we use `main` or `master` branch
- Always use `env:` variables and secrets attached to jobs instead of global workflows
- Always use `npm ci` for Node-based dependency setup
- Extract common steps into composite actions in separate files
- Once you're done, as a final step conduct the following: for each public action always use <tool>"Run Terminal"</tool> to see what is the most up-to-date version (use only major version) - extract tag_name from the response:
- ```bash curl -s https://api.github.com/repos/{owner}/{repo}/releases/latest ```

### Guidelines for CONTAINERIZATION

#### DOCKER

- Use multi-stage builds to create smaller production images
- Use non-root users in containers for better security
